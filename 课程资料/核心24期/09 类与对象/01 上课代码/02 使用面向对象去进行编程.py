std1 = { 'name': '小明', 'score': 98 }
# std2 = { 'name': '小红', 'score': 81 }
#
# # 首先使用普通的函数封装去写代码逻辑
# def fun1(stu):
#     print(stu['name'])  # 只是在函数内部去打印结果 并没有实现内外数据共享 所以函数外面返回的是一个none
#     return stu['name']  # 实现函数内外的数据共享
#
#
# # 调用函数 执行里面的代码逻辑
# print(fun1(std1))
#


# 面向对象的编程思维
# 类封装了很多个函数

# 1.先用Python类的封装

# 2.通过类创建实例化对象 然后去调用类里面的每一个函数  因为函数要被调用才会去执行自己的代码逻辑

# 如何去创建一个类
class Student:  # 创建类的关键字  Student---> 类的名字 类名最好首字母大写(查询员的默契) 默认遵循一下
    """
    类有属性:
         划分类的时候, 对于里面的所有对象  都是有一些相同属性
         实例属性 和 类属性

    类有方法:
            在类的所有对象中 能做做什么 针对问题去封装一个一个函数

    """

    # 函数在类中是具有特殊功能的函数 --> 初始化函数
    # 在后续使用类创建对象的时候, 这个函数会默认的被调用
    # 在初始化方法中, 创建的属性, 叫做实例属性
    # name=  '丸子' 默认参数
    def __init__(self,name,age):# 出现在init括号里面的需要绑定  name,age 只是我们传递进来的参数而已
        self.name = name #  名字属性 绑定到对象里面去
        self.age = age  # 名字年龄 绑定到对象里面去

    # 在类中定义的其他函数, 都叫做类的方法函数
    # 在类中, 可以通过 self 调用初始化函数中的实例属性
    def print_info(self):
        print(f'名字:{self.name},年龄{self.age}')
        return 111


    #定义一个吃的函数
    def eat(self):   # 如果你想在其中一个方法函数里面去调用另外一个方法函数  self
        self.print_info()
        return f'{self.name}正在吃东西'

# 对类进行实例化
# """基于封装的学生类, 创建学生对象""" 实例化对象
stu = Student('泽言',25)   # 返回的是一个实例化对象    __init__会被默认调用(自动启动)

# 2. 对象操作 通过类的实例化去调用实例属性
# print(stu.name)
# print(stu.age)
# # 调用函数 去执行里面的代码逻辑
# print(stu.print_info())
# print(stu.eat())

# """在类中, 基于类可以实例化多个对象""" (理论上是可以创建无数个的)
# stu2 = Student('丸子',20)
# print(stu2.name)  # stu2 只是一个别名 方便调用的

# 传递参数和讲的函数传参保持一致就可以了
print(Student(name='山禾',age=26).name)  # 按照位置参数一样传递的




